# 前言

Java语言已经发展了10多年，根据市场反馈，各行各业对Java语言的热度仍然不减，排行上仍然稳居第二，市场上对Java语言学习的热潮仍然没有退去，本项目聚集多个Java开发和架构高手，一起研究和总结JVM的核心技术和关键特性，每个知识点都配以案例和代码，并以文章的形式呈现给大家，最后整理成书，帮助更多的学习Java语言的小伙伴快速掌握Java的要领。

加进来的作者可以自行选择主题，围绕《Java核心要点和最佳实践》，可以独立成章，也可以写一个小节，暂时不用编号，直接按照题目新建文件夹即可。

# 作者

> 33493248@qq.com 李艳鹏

> jiaboyan@live.com 贾博岩

> 1428665561@qq.com 梁朋举

> chinazhaoht@gmail.com 赵宏涛

> ycuzjj@163.com 张军军

> jiaboyan@live.com 贾博岩

> 156418415@qq.com 杨彪

> 156418415@qq.com 徐凌云

# 阅稿人

N/A

# 目录

## 1 永恒的JVM GC

### 1.1 JVM内存管理

#### 1.1.1 常量池
#### 1.1.2 Java堆
##### 1.1.2.1 方法区
##### 1.1.2.2 新生代
##### 1.1.2.3 方法区
#### 1.1.3 Java栈
#### 1.1.4 本地方法栈
#### 1.1.5 PC计数器
#### 1.1.6 直接内存

### 1.2 GC过程

#### 1.2.1 Java中的引用类型
#### 1.2.1.1 强引用
#### 1.2.1.2 弱引用
#### 1.2.1.3 软引用
#### 1.2.1.4 幻影引用
#### 1.2.2 finalize方法的作用

### 1.3 GC算法

#### 1.3.1 引用计数
#### 1.3.2 分代复制
#### 1.3.3 标记清除
#### 1.3.4 标记清理
#### 1.3.5 标记整理

### 1.4 GC收集器

#### 1.4.1 串行收集器
#### 1.4.2 并行收集器
#### 1.4.3 并发收集器
#### 1.4.4 G1收集器

### 1.5 治理内存错误

#### 1.5.1 OutOfMemory
##### 1.5.1.1 Java heapspace error
##### 1.5.1.2 GC overhead limit exceeded
##### 1.5.1.3 Java permspace error
#### 1.5.2 StackOverflow
#### 1.5.3 内存问题实践案例


## 2 Java多线程

### 2.1 线程
### 2.2 ThreadLocal
### 2.3 线程池
- BlockingQueue
- 饱和策略
- 有界队列和无界队列

### 2.4 Actor模型

### 2.5 携程

## 3 Java并发机制

### 3.1 基础的同步工具

#### 3.1.1 Object类的wait、notify、notifyAll
#### 3.1.2 线程的suspend、resume、fork和join
#### 3.1.3 Synchronized和ReentrantLock
#### 3.1.4 Volatile和Synchronized

### 3.2 高级的同步工具

#### 3.2.1 AQS和Unsafe的park和unpark
#### 3.2.2 CAS
#### 3.2.3 原子变量
#### 3.2.4 Sephemore
- 可用于限流

#### 3.2.5 Barrier
#### 3.2.6 Latch
#### 3.2.7 读写锁

### 3.3 各种各样的锁

#### 3.3.1 锁的本质是排队
- 用排队比喻锁，画一张排队的图比喻锁，锁的排队的空间和时间不一样 

#### 3.3.2 应用层的锁
#### 3.3.3 悲观锁
#### 3.3.4 乐观锁
#### 3.3.5 分布式锁
#### 3.3.6 行级锁

### 3.4 最高境界是无锁

#### 3.4.1 不可变变量
#### 3.4.2 拆分后无竞争
#### 3.4.3 SpinLock
#### 3.4.4 Disruptor RingBuffer

## 3.5 解决棘手的并发问题

### 3.5.1 热点账户
- 账户热点，分而治之，大而化小，小而化了

#### 3.5.1 使用悲观锁
#### 3.5.1 使用悲观锁和分布式锁
#### 3.5.1 使用悲观锁和信号量
- 外面套分布式锁，降级为本地应用的sephamore

#### 3.5.1 使用行级锁
- 获得余额变动记录需要在同一个事务中再查询一次，比悲观所快一点

#### 3.5.1 使用行级锁和分布式锁
#### 3.5.1 使用行级锁和信号量
#### 3.5.1 账户拆分
- 需要业务逻辑允许


## 4 深入了解NIO的本质

### 4.1 Linux下IO的分类

#### 4.1.1 同步阻塞IO
#### 4.1.2 同步非阻塞IO
#### 4.1.3 基于信号的IO
#### 4.1.4 多路复用的IO
#### 4.1.5 异步IO

### 4.2 BIO、NIO和AIO的区别和场景

### 4.3 ByteBuffer的介绍和使用

### 4.4 零拷贝

### 4.5 线程模型
#### 4.5.1 BIO线程模型
#### 4.5.2 NIO线程模型

## 5 JVM类加载机制的深入剖析

### 5.1 双亲委派

### 5.2 ClassLoader类的解析

### 5.3 类的热加载

#### 5.3.1 Jsp ClassLoader

### 5.4 制造方法区内存溢出

### 5.5 计算法方法区大小

### 5.6 OSGI

### 5.7 JDK 9模块化

## 6 集合类 ---> 博岩

### 6.1 Collection、Set和List

### 6.2 HashTable和Hashmap

### 6.3 ArrayList

### 6.4 Queue

### 6.5 线程安全的集合

### 6.5.1 几代线程安全的集合

#### 6.5.1.1 与集合类耦合
#### 6.5.1.2 Collections.asSynchronized*
#### 6.5.1.3 提供单独的并发安全集合类

### 6.5.2 Cocurrent*

### 6.5.3 CopyOnWrite*

## 7 JVM优化

### 7.1 典型的JVM参数配置

### 7.2 堆设置调优

### 7.3 GC策略调优

### 7.4 JIT调优

### 7.5 JVM线程池调优
